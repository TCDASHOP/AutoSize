/* TCDA Size Guide - CSV to table (GitHub Pages)
   Deep links supported:
   - #p=hoodie&u=cm
   - #p=mensCrew&u=inch
*/

const products = [
  {
    id: "womensSlipon",
    name: "Women's slip-on canvas shoes",
    files: { cm: "data/womens_slipon_cm.csv", inch: "data/womens_slipon_inch.csv" }
  },
  {
    id: "mensSlipon",
    name: "Men's slip-on canvas shoes",
    files: { cm: "data/mens_slipon_cm.csv", inch: "data/mens_slipon_inch.csv" }
  }
];

const els = {
  productSelect: document.getElementById("productSelect"),
  btnCm: document.getElementById("btnCm"),
  btnInch: document.getElementById("btnInch"),
  title: document.getElementById("title"),
  status: document.getElementById("status"),
  table: document.getElementById("table"),
  copyBtn: document.getElementById("copyBtn"),
  downloadBtn: document.getElementById("downloadBtn"),
};

let state = {
  productId: products[0].id,
  unit: "cm"
};

function setStatus(msg) {
  els.status.textContent = msg || "";
}

function isValidProduct(id) {
  return products.some(p => p.id === id);
}

function parseHash() {
  const h = (location.hash || "").replace(/^#/, "");
  if (!h) return;
  const params = new URLSearchParams(h);
  const p = params.get("p");
  const u = params.get("u");
  if (p && isValidProduct(p)) state.productId = p;
  if (u === "cm" || u === "inch") state.unit = u;
}

function syncHash() {
  const params = new URLSearchParams();
  params.set("p", state.productId);
  params.set("u", state.unit);
  const next = "#" + params.toString();
  if (location.hash !== next) history.replaceState(null, "", next);
}

function setUnit(unit) {
  state.unit = unit;
  els.btnCm.setAttribute("aria-selected", unit === "cm" ? "true" : "false");
  els.btnInch.setAttribute("aria-selected", unit === "inch" ? "true" : "false");
  syncHash();
  render();
}

function getCurrentProduct() {
  return products.find(p => p.id === state.productId) || products[0];
}

function splitCSVLine(line) {
  // Simple CSV splitter (handles quoted commas)
  const out = [];
  let cur = "";
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === '"') {
      if (inQuotes && line[i + 1] === '"') { cur += '"'; i++; }
      else { inQuotes = !inQuotes; }
      continue;
    }
    if (ch === "," && !inQuotes) {
      out.push(cur.trim());
      cur = "";
      continue;
    }
    cur += ch;
  }
  out.push(cur.trim());
  return out;
}

function parseCSV(text) {
  const lines = text
    .replace(/\r\n/g, "\n")
    .replace(/\r/g, "\n")
    .split("\n")
    .filter(l => l.trim().length > 0);

  const rows = lines.map(splitCSVLine);

  // Detect "Unnamed:" header rows generated by some exports
  const firstRow = rows[0] || [];
  const looksUnnamed = firstRow.length > 0 && firstRow.every(c => /^Unnamed:/i.test(c));
  let headers = [];
  let data = [];

  if (looksUnnamed && rows.length >= 2) {
    headers = rows[1];
    data = rows.slice(2);
  } else {
    headers = firstRow;
    data = rows.slice(1);
  }

  // Remove empty trailing columns
  const trimCols = (arr) => {
    let end = arr.length;
    while (end > 0 && (arr[end - 1] ?? "").trim() === "") end--;
    return arr.slice(0, end);
  };
  headers = trimCols(headers);
  data = data.map(trimCols);

  return { headers, data };
}

function renderTable(headers, data) {
  const thead = document.createElement("thead");
  const trh = document.createElement("tr");
  headers.forEach(h => {
    const th = document.createElement("th");
    th.textContent = h;
    trh.appendChild(th);
  });
  thead.appendChild(trh);

  const tbody = document.createElement("tbody");
  data.forEach(row => {
    const tr = document.createElement("tr");
    headers.forEach((_, idx) => {
      const td = document.createElement("td");
      td.textContent = row[idx] ?? "";
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });

  els.table.innerHTML = "";
  els.table.appendChild(thead);
  els.table.appendChild(tbody);
}

async function fetchCSV(path) {
  const res = await fetch(path, { cache: "no-store" });
  if (!res.ok) throw new Error(`CSV読み込み失敗: ${res.status} ${res.statusText}`);
  return await res.text();
}

function updateTitle(product) {
  els.title.textContent = `${product.name} / ${state.unit}`;
}

function getCurrentCSVPath(product) {
  return state.unit === "cm" ? product.files.cm : product.files.inch;
}

function downloadCurrentCSV() {
  const product = getCurrentProduct();
  const path = getCurrentCSVPath(product);
  const a = document.createElement("a");
  a.href = path;
  a.download = path.split("/").pop();
  document.body.appendChild(a);
  a.click();
  a.remove();
}

function tableToTSV() {
  const headers = [...els.table.querySelectorAll("thead th")].map(th => th.textContent);
  const rows = [...els.table.querySelectorAll("tbody tr")].map(tr =>
    [...tr.querySelectorAll("td")].map(td => td.textContent)
  );
  const lines = [headers, ...rows].map(r => r.join("\t"));
  return lines.join("\n");
}

async function copyTable() {
  try {
    const tsv = tableToTSV();
    await navigator.clipboard.writeText(tsv);
    setStatus("コピーしました（TSV）");
    setTimeout(() => setStatus(""), 1200);
  } catch (e) {
    setStatus("コピーできませんでした（ブラウザの制限の可能性）");
  }
}

async function render() {
  const product = getCurrentProduct();
  updateTitle(product);

  const path = getCurrentCSVPath(product);
  setStatus(`読み込み中… ${path}`);
  try {
    const text = await fetchCSV(path);
    const { headers, data } = parseCSV(text);

    if (!headers.length) {
      renderTable(["Error"], [[`表のヘッダーが取れませんでした: ${path}`]]);
      setStatus("表示できるデータがありません");
      return;
    }

    renderTable(headers, data);

    // Placeholder detection (only header line)
    if (!data || data.length === 0) {
      setStatus("この商品はまだデータ未投入です（CSVを差し替えてください）");
    } else {
      setStatus("");
    }

  } catch (err) {
    renderTable(["Error"], [[String(err.message || err)]]);
    setStatus("CSVが見つからない / 読み込めない可能性があります（ファイル名を確認してください）");
  }
}

function init() {
  parseHash();

  // Populate select
  products.forEach(p => {
    const opt = document.createElement("option");
    opt.value = p.id;
    opt.textContent = p.name;
    els.productSelect.appendChild(opt);
  });
  els.productSelect.value = state.productId;

  // Initial unit UI
  els.btnCm.setAttribute("aria-selected", state.unit === "cm" ? "true" : "false");
  els.btnInch.setAttribute("aria-selected", state.unit === "inch" ? "true" : "false");

  syncHash();

  // Events
  els.productSelect.addEventListener("change", () => {
    state.productId = els.productSelect.value;
    syncHash();
    render();
  });

  els.btnCm.addEventListener("click", () => setUnit("cm"));
  els.btnInch.addEventListener("click", () => setUnit("inch"));

  els.copyBtn.addEventListener("click", copyTable);
  els.downloadBtn.addEventListener("click", downloadCurrentCSV);

  window.addEventListener("hashchange", () => {
    // If user opens a deep link, reflect it
    const prev = { ...state };
    parseHash();
    if (prev.productId !== state.productId) els.productSelect.value = state.productId;
    els.btnCm.setAttribute("aria-selected", state.unit === "cm" ? "true" : "false");
    els.btnInch.setAttribute("aria-selected", state.unit === "inch" ? "true" : "false");
    render();
  });

  render();
}

init();
